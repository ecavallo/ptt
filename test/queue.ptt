--------------------------------------------------------------------------------
-- Establishing a bridge between two implementations of a queue

-- See also a similar result using univalence, where the relation is made into
-- an equivalence by quotienting one implementation
-- https://github.com/agda/cubical/blob/master/Cubical/Data/Queue/Base.agda
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Prelude
--------------------------------------------------------------------------------

let symm : (A : U<0>) (a : A) (b : A) -> (Id A a b) -> Id A b a =
  fun A a b eq ->
  match eq at a0 a1 _ -> Id A a1 a0 with
  | refl a -> refl a

let trans : (A : U<0>) (a : A) (b : A) (c : A) -> (Id A a b) -> (Id A b c) -> Id A a c =
  fun A a b c eq0 ->
  match eq0 at x y _ -> (Id A y c) -> Id A x c with
  | refl z -> fun eq1 -> eq1

let cong : (A : U<0>) (B : U<0>) (f : A -> B) (a0 : A) (a1 : A)
  -> (Id A a0 a1) -> Id B (f a0) (f a1)
  =
  fun A B f a0 a1 eq ->
  match eq at a0 a1 _ -> Id B (f a0) (f a1) with
  | refl z -> refl (f z)

let subst : (A : U<0>) (B : A -> U<0>)
  (a0 : A) (a1 : A) (eq : Id A a0 a1)
  -> (B a0) -> B a1
  =
  fun A B a0 a1 eq ->
  match eq at a0 a1 _ -> (B a0) -> B a1 with
  | refl _ -> fun b -> b

let substinv : (A : U<0>) (B : A -> U<0>)
  (a0 : A) (a1 : A) (eq : Id A a0 a1)
  -> (B a1) -> B a0
  =
  fun A B a0 a1 eq ->
  subst A B a1 a0 (symm A a0 a1 eq)

let based1_J : (A : U<0>) (a1 : A)
  (B : (a0 : A) (eq : Id A a0 a1) -> U<0>) (b : B a1 (refl a1))
  (a0 : A) (eq : Id A a0 a1) -> B a0 eq
  =
  fun A a1 B b a0 eq ->
  (match eq at a0 a1 eq ->
     (B : (a0 : A) (eq : Id A a0 a1) -> U<0>) (b : B a1 (refl a1)) -> B a0 eq
   with
   | refl _ -> fun B b -> b)
  B b

let Bridge : (A : [_] U<0> {*; *}) -> (A @ 0) -> (A @ 1) -> U<0> =
  fun A a0 a1 -> [x] (A @ x) {a0; a1}

let gelproj : (A : U<0>) (B : U<0>) (R : A -> B -> U<0>)
  (p : [x] Gel x {A; B} (a b -> R a b) {*; *}) -> R (p @ 0) (p @ 1)
  =
  fun A B R p ->
  ungel x : 2 -> p @ x at _ -> R (p @ 0) (p @ 1) with | gel r -> r

let IdGel : (A : U<0>) -> [_] U<0> {A; A} =
  fun A -> bri x -> Gel x {A; A} (a a' -> Id A a a')

--------------------------------------------------------------------------------
-- Operations on relations
--------------------------------------------------------------------------------

let cospan_to_rel : (A : U<0>) (B : U<0>) (C : U<0>) (f : A -> C) (g : B -> C)
 -> A -> B -> U<0>
 =
 fun A B C f g a b -> Id C (f a) (g b)

let rel_id : (A : U<0>) -> A -> A -> U<0> =
  fun A a a' -> Id A a a'

let rel_compose : (A : U<0>) (B : U<0>) (C : U<0>)
  -> (A -> B -> U<0>)
  -> (B -> C -> U<0>)
  -> (A -> C -> U<0>)
  =
  fun A B C R S a c ->
  (b : B) * (R a b) * S b c

let rel_unitl : (A : U<0>) (B : U<0>) (R : A -> B -> U<0>)
  (a : A) (b : B)
  -> (rel_compose A A B (rel_id A) R a b) -> R a b
  =
  fun A B R a b r ->
  substinv A (fun t -> R t b) a (fst r) (fst (snd r)) (snd (snd r))

--------------------------------------------------------------------------------
-- Bridge-discreteness of bool (one direction)
--------------------------------------------------------------------------------

let shannon : bool -> bool =
  fun b ->
  if b at _ -> bool with | tt -> tt | ff -> ff

let bool_eta : (b : bool) -> Id bool (shannon b) b =
  fun b ->
  if b at b -> Id bool (shannon b) b with
  | tt -> refl tt
  | ff -> refl ff

let bridge_to_id : (b0 : bool) (b1 : bool) -> [_] bool {b0; b1} -> Id bool b0 b1 =
  fun b0 b1 p ->
  let lemma : Id bool (shannon b0) (shannon b1) =
    gelproj bool bool (fun c d -> Id bool c d)
      (bri x ->
       if (p @ x) at _ -> Gel x {bool; bool} (c d -> Id bool c d) with
       | tt -> gel x {tt; tt} (refl tt)
       | ff -> gel x {ff; ff} (refl ff))
  in
  trans bool b0 (shannon b1) b1
    (trans bool b0 (shannon b0) (shannon b1)
      (symm bool (shannon b0) b0 (bool_eta b0))
      lemma)
    (bool_eta b1)

--------------------------------------------------------------------------------
-- Products
--------------------------------------------------------------------------------

let product_rel :
  (A0 : U<0>) (A1 : U<0>) (A : A0 -> A1 -> U<0>)
  (B0 : U<0>) (B1 : U<0>) (B : B0 -> B1 -> U<0>)
  -> (A0 * B0) -> (A1 * B1) -> U<0>
  =
  fun A0 A1 A B0 B1 B ab0 ab1 ->
  (A (fst ab0) (fst ab1)) * B (snd ab0) (snd ab1)

--------------------------------------------------------------------------------
-- Options
--------------------------------------------------------------------------------

let option : U<0> -> U<0> = fun A -> unit + A

let option_map : (A : U<0>) (B : U<0>) -> (A -> B) -> (option A) -> option B =
  fun A B f op ->
  case op at _ -> option B with
  | inl _ -> inl triv
  | inr a -> inr (f a)

let option_rel : (A0 : U<0>) (A1 : U<0>) (A : A0 -> A1 -> U<0>)
  -> (option A0) -> (option A1) -> U<0>
  =
  fun A0 A1 A op0 ->
  case op0 at _ -> (option A1) -> U<0> with
  | inl _ -> fun op1 ->
    case op1 at _ -> U<0> with
    | inl _ -> unit
    | inr _ -> void
  | inr a0 -> fun op1 ->
    case op1 at _ -> U<0> with
    | inl _ -> void
    | inr a1 -> A a0 a1

let option_encode : (A : U<0>) (op0 : option A) (op1 : option A)
  -> (Id (option A) op0 op1) -> option_rel A A (rel_id A) op0 op1
  =
  fun A op0 op1 eq ->
  match eq at op0 op1 _ -> option_rel A A (rel_id A) op0 op1 with
  | refl op ->
    case op at op -> option_rel A A (rel_id A) op op with
    | inl _ -> triv
    | inr a -> refl a

--------------------------------------------------------------------------------
-- Lists
--------------------------------------------------------------------------------

let list_map : (A : U<0>) (B : U<0>) -> (A -> B) -> (list A) -> list B =
  fun A B f l ->
  listrec l at _ -> list B with
  | nil -> nil
  | cons a as, bs -> cons (f a) bs

let split : (A : U<0>) -> (list A) -> option (A * list A) =
  fun A as ->
  listrec as at _ -> option (A * list A) with
  | nil -> inl triv
  | cons a as, _ -> inr <a, as>

let snoc : (A : U<0>) -> (list A) -> A -> list A =
  fun A bs a ->
  listrec bs at _ -> list A with
  | nil -> cons a nil
  | cons b bs, bs' -> cons b bs'

let rev : (A : U<0>) -> (list A) -> list A =
  fun A as ->
  listrec as at _ -> list A with
  | nil -> nil
  | cons a as, as' -> snoc A as' a

let append : (A : U<0>) -> (list A) -> (list A) -> list A =
  fun A as bs ->
  listrec as at _ -> list A with
  | nil -> bs
  | cons a as, cs -> cons a cs

let append_nil : (A : U<0>) (as : list A) ->
  Id (list A) as (append A as nil)
  =
  fun A as ->
  listrec as at as -> Id (list A) as (append A as nil) with
  | nil -> refl nil
  | cons a as, eq ->
    cong (list A) (list A) (fun t -> cons a t) as (append A as nil) eq

let snoc_append : (A : U<0>)
  (as : list A) (bs : list A) (b : A)
  -> Id (list A) (snoc A (append A as bs) b) (append A as (snoc A bs b))
  =
  fun A as bs b ->
  listrec as at as -> Id (list A) (snoc A (append A as bs) b) (append A as (snoc A bs b)) with
  | nil -> refl (snoc A bs b)
  | cons a as, eq ->
    cong (list A) (list A) (fun t -> cons a t)
      (snoc A (append A as bs) b)
      (append A as (snoc A bs b))
      eq

let snoc_rev : (A : U<0>) (as : list A) (b : A)
  -> Id (list A) (snoc A (rev A as) b) (rev A (cons b as))
  =
  fun A as b -> refl (rev A (cons b as))

--------------------------------------------------------------------------------
-- Lemmas about the result type of "pop"
--------------------------------------------------------------------------------

let pop_result_map : (A : U<0>) (B : U<0>) (C : U<0>) (f : B -> C)
  -> (option (A * B)) -> option (A * C)
  =
  fun A B C f ->
  option_map (A * B) (A * C) (fun a_b -> <fst a_b, f (snd a_b)>)

let pop_result_map_conc : (A : U<0>) (B : U<0>) (C : U<0>) (D : U<0>)
  (g : C -> D) (f : B -> C) (r : option (A * B))
  -> Id (option (A * D))
     (pop_result_map A B D (fun b -> g (f b)) r)
     (pop_result_map A C D g (pop_result_map A B C f r))
  =
  fun A B C D g f r ->
  case r at r ->
    Id (option (A * D))
      (pop_result_map A B D (fun b -> g (f b)) r)
      (pop_result_map A C D g (pop_result_map A B C f r))
  with
  | inl _ -> refl (inl triv)
  | inr a_b -> refl (inr <fst a_b, g (f (snd a_b))>)

-- annoying formulation thanks to lack of funext ;)
let pop_result_map_id : (A : U<0>) (B : U<0>)
  (f : B -> B) (eq : (b : B) -> Id B b (f b)) (r : option (A * B))
  -> Id (option (A * B)) r (pop_result_map A B B f r)
  =
  fun A B f eq r ->
  case r at r -> Id (option (A * B)) r (pop_result_map A B B f r) with
  | inl _ -> refl (inl triv)
  | inr a_b ->
    cong B (option (A * B)) (fun b -> inr <fst a_b, b>)
      (snd a_b)
      (f (snd a_b))
      (eq (snd a_b))

let pop_result_rel :
  (A0 : U<0>) (A1 : U<0>) (A : A0 -> A1 -> U<0>)
  (B : U<0>) (C : U<0>) (R : B -> C -> U<0>)
  -> (option (A0 * B)) -> (option (A1 * C)) -> U<0>
  =
  fun A0 A1 A B C R ->
  option_rel (A0 * B) (A1 * C) (product_rel A0 A1 A B C R)

let pop_result_rel_map :
  (A0 : U<0>) (A1 : U<0>) (A : A0 -> A1 -> U<0>) (A' : A0 -> A1 -> U<0>)
  (B : U<0>) (C : U<0>) (R : B -> C -> U<0>) (R' : B -> C -> U<0>)
  (f : (a0 : A0) (a1 : A1) -> (A a0 a1) -> A' a0 a1)
  (g : (b : B) (c : C) -> (R b c) -> R' b c)
  (ob : option (A0 * B)) (oc : option (A1 * C))
  -> (pop_result_rel A0 A1 A B C R ob oc)
  -> pop_result_rel A0 A1 A' B C R' ob oc
  =
  fun A0 A1 A A' B C R R' f g ob ->
  case ob at ob ->
    (oc : option (A1 * C))
    -> (pop_result_rel A0 A1 A B C R ob oc)
    -> pop_result_rel A0 A1 A' B C R' ob oc
  with
  | inl _ -> fun oc ->
    case oc at oc ->
      (pop_result_rel A0 A1 A B C R (inl triv) oc)
      -> pop_result_rel A0 A1 A' B C R' (inl triv) oc
    with
    | inl _ -> fun _ -> triv
    | inr _ -> fun bot -> bot
  | inr a_b -> fun oc ->
    case oc at oc ->
      (pop_result_rel A0 A1 A B C R (inr a_b) oc)
      -> pop_result_rel A0 A1 A' B C R' (inr a_b) oc
    with
    | inl _ -> fun bot -> bot
    | inr a_c -> fun a_r ->
      < f (fst a_b) (fst a_c) (fst a_r)
      , g (snd a_b) (snd a_c) (snd a_r)
      >

let pop_result_bridge : (A : [_] U<0> {*; *}) (B : [_] U<0> {*; *})
  (ob : option ((A @ 0) * B @ 0)) (oc : option ((A @ 1) * B @ 1))
  -> (pop_result_rel (A @ 0) (A @ 1) (Bridge A) (B @ 0) (B @ 1) (Bridge B) ob oc)
  -> [x] option ((A @ x) * (B @ x)) {ob; oc}
  =
  fun A B ob ->
  case ob at ob ->
    (oc : option ((A @ 1) * (B @ 1)))
    -> (pop_result_rel (A @ 0) (A @ 1) (Bridge A) (B @ 0) (B @ 1) (Bridge B) ob oc)
    -> [x] option ((A @ x) * (B @ x)) {ob; oc}
  with
  | inl _ -> fun oc ->
    case oc at oc ->
      (pop_result_rel (A @ 0) (A @ 1) (Bridge A) (B @ 0) (B @ 1) (Bridge B) (inl triv) oc)
      -> [x] option ((A @ x) * (B @ x)) {inl triv; oc}
    with
    | inl _ -> fun _ -> bri _ -> inl triv
    | inr a_c -> fun bot ->
      abort bot at _ -> [x] option ((A @ x) * (B @ x)) {inl triv; inr a_c}
  | inr a_b -> fun oc ->
    case oc at oc ->
      (pop_result_rel (A @ 0) (A @ 1) (Bridge A) (B @ 0) (B @ 1) (Bridge B) (inr a_b) oc)
      -> [x] option ((A @ x) * (B @ x)) {inr a_b; oc}
    with
    | inl _ -> fun bot ->
      abort bot at _ -> [x] option ((A @ x) * (B @ x)) {inr a_b; inl triv}
    | inr a_c -> fun a_r ->
      bri x -> inr <fst a_r @ x, snd a_r @ x>

-- TODO generalize
let pop_result_revgraph : (A : U<0>) (B : U<0>) (C : U<0>) (g : C -> B)
  (rb : option (A * B)) (rc : option (A * C))
  -> (Id (option (A * B)) rb (pop_result_map A C B g rc))
  -> pop_result_rel A A (rel_id A) B C (cospan_to_rel B C B (fun b -> b) g) rb rc
  =
  fun A B C g rb rc eq ->
  based1_J (option (A * B)) (pop_result_map A C B g rc)
    (fun rb _ -> pop_result_rel A A (rel_id A) B C (cospan_to_rel B C B (fun b -> b) g) rb rc)
    (case rc at rc ->
        pop_result_rel A A (rel_id A) B C (cospan_to_rel B C B (fun b -> b) g) (pop_result_map A C B g rc) rc
      with
      | inl _ -> triv
      | inr a_c -> <refl (fst a_c), refl (g (snd a_c))>)
    rb
    eq

--------------------------------------------------------------------------------
-- Queue implementation with a single list
--------------------------------------------------------------------------------

let queue1 : U<0> -> U<0> =
  fun A -> list A

let empty1 : (A : U<0>) -> queue1 A =
  fun A -> nil

let push1 : (A : U<0>) -> A -> (queue1 A) -> queue1 A =
  fun A a as -> snoc A as a

let pop1 : (A : U<0>) -> (queue1 A) -> option (A * queue1 A) =
  split

--------------------------------------------------------------------------------
-- Queue implementation with a pair of lists
--------------------------------------------------------------------------------

let queue2 : U<0> -> U<0> =
  fun A -> (list A) * list A

let empty2 : (A : U<0>) -> queue2 A =
  fun A -> <nil, nil>

let push2 : (A : U<0>) -> A -> (queue2 A) -> queue2 A =
  fun A a q ->
  <cons a (fst q), snd q>

let pop2 : (A : U<0>) -> (queue2 A) -> option (A * queue2 A) =
  fun A q ->
  listrec (snd q) at _ -> option (A * queue2 A) with
  | nil ->
    pop_result_map A (list A) (queue2 A)
      (fun as -> <nil, as>)
      (split A (rev A (fst q)))
  | cons a as, _ -> inr <a, <fst q, as>>

--------------------------------------------------------------------------------
-- Homomorphism between the two implementations
--------------------------------------------------------------------------------

let flatten : (A : U<0>) -> (queue2 A) -> list A =
   fun A q -> append A (snd q) (rev A (fst q))

let flatten_push : (A : U<0>) (a : A) (q : queue2 A)
  -> Id (list A) (push1 A a (flatten A q)) (flatten A (push2 A a q))
  =
  fun A a q ->
  trans (list A)
    (snoc A (append A (snd q) (rev A (fst q))) a)
    (append A (snd q) (snoc A (rev A (fst q)) a))
    (append A (snd q) (rev A (cons a (fst q))))
    (snoc_append A (snd q) (rev A (fst q)) a)
    (cong (list A) (list A) (fun t -> append A (snd q) t)
      (snoc A (rev A (fst q)) a)
      (rev A (cons a (fst q)))
      (snoc_rev A (fst q) a))

let flatten_pop_lemma : (A : U<0>) (as : list A)
  -> Id (option (A * list A))
     (pop1 A (flatten A <as,nil>))
     (pop_result_map A (queue2 A) (list A) (flatten A) (pop2 A <as,nil>))
  =
  fun A as ->
  trans (option (A * list A))
    (pop1 A (flatten A <as,nil>))
    (pop_result_map A (list A) (list A) (fun as -> flatten A <nil,as>) (split A (rev A as)))
    (pop_result_map A (queue2 A) (list A) (flatten A) (pop2 A <as,nil>))
    (pop_result_map_id A (list A) (fun as -> append A as nil) (append_nil A) (split A (rev A as)))
    (pop_result_map_conc A (list A) (queue2 A) (list A)
      (flatten A) (fun as -> <nil,as>)
      (split A (rev A as)))

let flatten_pop : (A : U<0>) (q : queue2 A)
  -> Id (option (A * list A))
     (pop1 A (flatten A q))
     (pop_result_map A (queue2 A) (list A) (flatten A) (pop2 A q))
  =
  fun A q ->
  let lem : (bs : list A) (as : list A)
    -> Id (option (A * list A))
       (pop1 A (flatten A <as,bs>))
       (pop_result_map A (queue2 A) (list A) (flatten A) (pop2 A <as,bs>))
    =
    fun bs ->
    listrec bs at bs ->
      (as : list A)
      -> Id (option (A * list A))
         (pop1 A (flatten A <as,bs>))
         (pop_result_map A (queue2 A) (list A) (flatten A) (pop2 A <as,bs>))
    with
    | nil -> flatten_pop_lemma A
    | cons b bs, _ -> fun as -> refl (inr <b, flatten A <as,bs>>)
  in
  lem (snd q) (fst q)

--------------------------------------------------------------------------------
-- Abstract type of queues
--------------------------------------------------------------------------------

let QUEUE : (A : U<0>) -> U<1> =
  fun A ->
  (Q : U<0>)
  * Q
  * (A -> Q -> Q)
  * (Q -> option (A * Q))

let QUEUE' : U<1> =
  (A : U<0>) * QUEUE A

let ty : (A : U<0>) -> (QUEUE A) -> U<0> =
  fun A Q -> fst Q

let empty : (A : U<0>) (Q : QUEUE A) -> ty A Q =
  fun A Q -> fst (snd Q)

let push : (A : U<0>) (Q : QUEUE A) -> A -> (ty A Q) -> ty A Q =
  fun A Q -> fst (snd (snd Q))

let pop : (A : U<0>) (Q : QUEUE A) -> (ty A Q) -> option (A * ty A Q) =
  fun A Q -> snd (snd (snd Q))

let QUEUE_REL : (A0 : U<0>) (A1 : U<0>) (A : A0 -> A1 -> U<0>)
  -> (QUEUE A0) -> (QUEUE A1) -> U<1>
  =
  fun A0 A1 A Q0 Q1 ->
  (R : (ty A0 Q0) -> (ty A1 Q1) -> U<0>)
  * (Remp : R (empty A0 Q0) (empty A1 Q1))
  * (Rpush : (a0 : A0) (a1 : A1) (a : A a0 a1) (q0 : ty A0 Q0) (q1 : ty A1 Q1)
      -> (R q0 q1) -> R (push A0 Q0 a0 q0) (push A1 Q1 a1 q1))
  * ((q0 : ty A0 Q0) (q1 : ty A1 Q1)
      -> (R q0 q1)
      -> pop_result_rel A0 A1 A (ty A0 Q0) (ty A1 Q1) R
           (pop A0 Q0 q0) (pop A1 Q1 q1))

let QUEUE_Gel : (A : [_] U<0> {*; *}) (Q0 : QUEUE (A@0)) (Q1 : QUEUE (A@1))
  (R : (ty (A@0) Q0) -> (ty (A@1) Q1) -> U<0>)
  (Remp : R (empty (A@0) Q0) (empty (A@1) Q1))
  (Rpush : (a : [x] A@x {*; *}) (q0 : ty (A@0) Q0) (q1 : ty (A@1) Q1)
    -> (R q0 q1) -> R (push (A@0) Q0 (a@0) q0) (push (A@1) Q1 (a@1) q1))
  (Rpop : (q0 : ty (A@0) Q0) (q1 : ty (A@1) Q1)
    -> (R q0 q1)
    -> pop_result_rel (A@0) (A@1) (Bridge A) (ty (A@0) Q0) (ty (A@1) Q1) R
       (pop (A@0) Q0 q0) (pop (A@1) Q1 q1))
  -> [x] QUEUE (A@x) {Q0; Q1}
  =
  fun A Q0 Q1 R Remp Rpush Rpop ->
  let Q : [_] U<0> {ty (A@0) Q0; ty (A@1) Q1} =
    bri x -> Gel x {ty (A@0) Q0; ty (A@1) Q1} (q0 q1 -> R q0 q1)
  in
  let ty0 = ty (A@0) Q0 in
  let ty1 = ty (A@1) Q1 in
  let empty0 = empty (A@0) Q0 in
  let empty1 = empty (A@1) Q1 in
  let push0 = push (A@0) Q0 in
  let push1 = push (A@1) Q1 in
  let pop0 = pop (A@0) Q0 in
  let pop1 = pop (A@1) Q1 in
  bri x ->
  < Q @ x
  , < gel x {empty (A@0) Q0; empty (A@1) Q1} Remp
    , < fun a q ->
        extent x of <a,q> in x -> (A @ x) * Q @ x at x _ -> Q @ x with
        | aq0 -> push0 (fst aq0) (snd aq0)
        | aq1 -> push1 (fst aq1) (snd aq1)
        | aq0 aq1 aqx x ->
          gel x {push0 (fst aq0) (snd aq0); push1 (fst aq1) (snd aq1)}
            (Rpush (bri x -> fst (aqx @ x))
              (snd aq0) (snd aq1)
              (gelproj ty0 ty1 R (bri x -> snd (aqx @ x))))
      , fun q ->
        extent x of q in x -> Q @ x at x _ -> option ((A @ x) * Q @ x) with
        | q0 -> pop0 q0
        | q1 -> pop1 q1
        | q0 q1 qx x ->
          pop_result_bridge A Q (pop0 q0) (pop1 q1)
            (pop_result_rel_map
              (A@0) (A@1) (Bridge A) (Bridge A)
              ty0 ty1 R (Bridge (bri x -> Gel x {ty0; ty1} (q0 q1 -> R q0 q1)))
              (fun _ _ a -> a)
              (fun q0 q1 r -> bri x -> gel x {q0; q1} r)
              (pop0 q0) (pop1 q1)
              (Rpop q0 q1 (gelproj ty0 ty1 R qx)))
            @ x
      >
    >
  >

let QUEUE_Gel' : (A0 : U<0>) (A1 : U<0>) (A : A0 -> A1 -> U<0>)
  (Q0 : QUEUE A0) (Q1 : QUEUE A1) (Q : QUEUE_REL A0 A1 A Q0 Q1)
  -> [x] QUEUE (Gel x {A0; A1} (a0 a1 -> A a0 a1)) {Q0; Q1}
  =
  fun A0 A1 A Q0 Q1 Q ->
  let R = fst Q in
  let Remp = fst (snd Q) in
  let Rpush = fst (snd (snd Q)) in
  let Rpop = snd (snd (snd Q)) in
  QUEUE_Gel
    (bri x -> Gel x {A0; A1} (a0 a1 -> A a0 a1))
    Q0 Q1 R
    Remp
    (fun a q0 q1 r ->
      Rpush (a @ 0) (a @ 1) (gelproj A0 A1 A a) q0 q1 r)
    (fun q0 q1 r ->
      pop_result_rel_map
        A0 A1 A (Bridge (bri x -> Gel x {A0; A1} (a0 a1 -> A a0 a1)))
        (ty A0 Q0) (ty A1 Q1) R R
        (fun a0 a1 a -> bri x -> gel x {a0; a1} a)
        (fun _ _ r -> r)
        (pop A0 Q0 q0)
        (pop A1 Q1 q1)
        (Rpop q0 q1 r))

--------------------------------------------------------------------------------
-- The two implementations are connected by a bridge in QUEUE
--------------------------------------------------------------------------------

let queue_struct1 : (A : U<0>) -> QUEUE A =
  fun A -> <queue1 A, <empty1 A, <push1 A, pop1 A>>>

let queue_struct2 : (A : U<0>) -> QUEUE A =
  fun A -> <queue2 A, <empty2 A, <push2 A, pop2 A>>>

let queue12_rel : (A : U<0>)
  -> QUEUE_REL A A (rel_id A) (queue_struct1 A) (queue_struct2 A)
  =
  fun A ->
  < fun q1 q2 -> Id (list A) q1 (flatten A q2)
  , < refl nil
    , < fun a1 a2 eqa q1 q2 relq ->
        trans (list A)
          (push1 A a1 q1)
          (push1 A a2 q1)
          (flatten A (push2 A a2 q2))
          (cong A (list A) (fun a -> push1 A a q1) a1 a2 eqa)
          (trans (list A)
            (push1 A a2 q1)
            (push1 A a2 (flatten A q2))
            (flatten A (push2 A a2 q2))
            (cong (list A) (list A) (push1 A a2) q1 (flatten A q2) relq)
            (flatten_push A a2 q2))
      , fun q1 q2 relq ->
        pop_result_revgraph A (queue1 A) (queue2 A) (flatten A)
          (pop1 A q1)
          (pop2 A q2)
          (trans (option (A * list A))
            (pop1 A q1)
            (pop1 A (flatten A q2))
            (pop_result_map A (queue2 A) (queue1 A) (flatten A) (pop2 A q2))
            (cong (list A) (option (A * list A)) (pop1 A) q1 (flatten A q2) relq)
            (flatten_pop A q2))
      >
    >
  >

-- TODO for this to be useful, we should replace IdGel A with an arbitrary bridge
let queue12_bridge : (A : U<0>)
  -> [x] (QUEUE (IdGel A @ x)) {queue_struct1 A; queue_struct2 A}
  =
  fun A ->
  QUEUE_Gel' A A (rel_id A) (queue_struct1 A) (queue_struct2 A) (queue12_rel A)
