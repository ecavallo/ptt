--------------------------------------------------------------------------------
-- Part of a proof that nat is bridge-discrete
-- Unclear if the full result follows from nullary parametricity
--------------------------------------------------------------------------------

-- Identity type lemmas

let subst : (A : nat -> U<0>) (n : nat) (m : nat) -> (Id nat n m) -> (A n) -> (A m) =
  fun A n m prf ->
  match prf at x y prf -> (A x) -> (A y) with
  | refl _ -> fun x -> x

normalize def subst

let cong : (A : U<0>) (B : U<0>) (f : A -> B) (a0 : A) (a1 : A)
  -> (Id A a0 a1) -> Id B (f a0) (f a1)
  =
  fun A B f a0 a1 eq ->
  match eq at x0 x1 _ -> Id B (f x0) (f x1) with
  | refl z -> refl (f z)

normalize def cong

-- Gel type lemmas

let gelproj : (A : U<0>) -> [x] Gel x A {} -> A =
  fun A p ->
  ungel x -> p @ x at _ -> A with | gel a -> a

normalize def gelproj

let mapGel : (A : U<0>) (B : U<0>) -> (A -> B) -> [x] (Gel x A) -> Gel x B {} =
  fun A B f -> bri x -> fun g ->
  extent x of g in y -> Gel y A at y _ -> Gel y B with
  | q y -> gel y (f (gelproj A q))

normalize def mapGel

-- nat is a retract of [x] nat {}

let stretch : nat -> [x] nat {} =
  fun n -> bri _ -> n

normalize def stretch

let flatten_aux : [x] nat -> Gel x nat {} =
  bri x -> fun n ->
  rec n at _ -> Gel x nat with
  | zero -> gel x zero
  | suc _, g -> mapGel nat nat (fun m -> suc m) @ x g

normalize def flatten_aux

let flatten : [x] nat {} -> nat =
  fun p -> gelproj nat (bri x -> flatten_aux @ x (p @ x))

normalize def flatten

let flatten_stretch : (n : nat) -> Id nat (flatten (stretch n)) n =
  fun n ->
  rec n at n -> Id nat (flatten (stretch n)) n with
  | zero -> refl zero
  | suc k, q -> cong nat nat (fun m -> suc m) (flatten (stretch k)) k q

normalize def flatten_stretch

-- can we prove that this is an equivalence (modulo bridge extensionality),
-- or do we need binary parametricity?
-- let stretch_flatten : (p : [x] nat {}) -> Id ([x] nat {}) (stretch (flatten p)) p =
