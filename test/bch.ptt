--------------------------------------------------------------------------------
-- An (incomplete) experiment with using parametric type theory as an internal
-- language of BCH cubical sets to develop the BCH model of cubical type theory
-- in Orton-Pitts style.

-- It's not obvious how to specify dependent Path-types or G-types in this way,
-- because we cannot express the separated product of a context with an
-- interval. It's also likely that interpreting parametric type theory in the
-- naive way will not give the same definition of fibration as in the BCH
-- paper. (See Section 9.3 in Swan, "Lifting Problems in Grothendieck
-- Fibrations".)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Postulates
--------------------------------------------------------------------------------

postulate is_cof : U<0> -> U<0>

let cof : U<1> = (c : U<0>) * is_cof c
let decode : cof -> U<0> = fun c -> fst c

postulate empty : U<0>
postulate abort_empty : empty -> (A : U<0>) -> A

postulate empty_is_cof : is_cof empty

postulate bdy_is_cof : (c : U<0>) (r : is_cof c)
  -> [x] is_cof (Gel x {unit; unit} (_ _ -> c)) {* ; *}

let is_prop : (A : U<0>) -> U<0> =
  fun A -> (a : A) (b : A) -> Id A a b

postulate cof_is_prop : (c : cof) -> is_prop (decode c)

let cof_empty : cof = <empty, empty_is_cof>

let cof_bdy : cof -> [x] cof {*; *} =
  fun c -> bri x ->
  <Gel x {unit; unit} (_ _ -> fst c), bdy_is_cof (fst c) (snd c) @ x>

postulate funext : (A : U<0>) (B : A -> U<0>) (f0 : (a : A) -> B a) (f1 : (a : A) -> B a)
  -> ((a : A) -> Id (B a) (f0 a) (f1 a)) -> Id ((a : A) -> B a) f0 f1

postulate uip : (A : U<0>) (a0 : A) (a1 : A) -> is_prop (Id A a0 a1)

-- Note that because we do not require the input identity to be refl at x = 0
-- and x = 1, this postulate implicitly invokes UIP
postulate briext : (A : [x] U<0> {*; *})
  (p0 : [x] A @ x {*; *}) (p1 : [x] A @ x {p0 @ 0; p0 @ 1})
  -> ([x] Id (A @ x) (p0 @ x) (p1 @ x) {*; *})
  -> Id ([x] A @ x {p0 @ 0; p0 @ 1}) (bri x -> p0 @ x) p1

--------------------------------------------------------------------------------
-- Preliminary
--------------------------------------------------------------------------------

let based0_J : (A : U<0>) (a0 : A)
  (B : (a1 : A) (eq : Id A a0 a1) -> U<0>) (b : B a0 (refl a0))
  (a1 : A) (eq : Id A a0 a1) -> B a1 eq
  =
  fun A a0 B b a1 eq ->
  (match eq at a0 a1 eq ->
     (B : (a1 : A) (eq : Id A a0 a1) -> U<0>) (b : B a0 (refl a0)) -> B a1 eq
   with
   | refl _ -> fun B b -> b)
  B b

let based1_J : (A : U<0>) (a1 : A)
  (B : (a0 : A) (eq : Id A a0 a1) -> U<0>) (b : B a1 (refl a1))
  (a0 : A) (eq : Id A a0 a1) -> B a0 eq
  =
  fun A a1 B b a0 eq ->
  (match eq at a0 a1 eq ->
     (B : (a0 : A) (eq : Id A a0 a1) -> U<0>) (b : B a1 (refl a1)) -> B a0 eq
   with
   | refl _ -> fun B b -> b)
  B b

let symm : (A : U<0>) (a : A) (b : A) -> (Id A a b) -> Id A b a =
  fun A a b eq ->
  match eq at a0 a1 _ -> Id A a1 a0 with
  | refl a -> refl a

let trans : (A : U<0>) (a : A) (b : A) (c : A) -> (Id A a b) -> (Id A b c) -> Id A a c =
  fun A a b c eq0 ->
  match eq0 at x y _ -> (Id A y c) -> Id A x c with
  | refl z -> fun eq1 -> eq1

let subst : (A : U<0>) (B : A -> U<0>)
  (a0 : A) (a1 : A) (eq : Id A a0 a1)
  -> (B a0) -> B a1
  =
  fun A B a0 a1 eq ->
  match eq at a0 a1 _ -> (B a0) -> B a1 with
  | refl _ -> fun b -> b

let substinv : (A : U<0>) (B : A -> U<0>)
  (a0 : A) (a1 : A) (eq : Id A a0 a1)
  -> (B a1) -> B a0
  =
  fun A B a0 a1 eq ->
  subst A B a1 a0 (symm A a0 a1 eq)

let subst2 : (A : U<0>) (B : U<0>) (C : A -> B -> U<0>)
  (a0 : A) (a1 : A) (eqA : Id A a0 a1)
  (b0 : B) (b1 : B) (eqB : Id B b0 b1)
  -> (C a0 b0) -> C a1 b1
  =
  fun A B C a0 a1 eq ->
  match eq at a0 a1 _ -> (b0 : B) (b1 : B) -> (Id B b0 b1) -> (C a0 b0) -> C a1 b1 with
  | refl a -> subst B (C a)

let subst_ends : (A : [x] U<0> {*; *}) (p : [x] A @ x {*; *})
  (a0 : A @ 0) (eq0 : Id (A @ 0) (p @ 0) a0)
  (a1 : A @ 1) (eq1 : Id (A @ 1) (p @ 1) a1)
  -> [x] A @ x {a0; a1}
  =
  fun A p a0 eq0 a1 eq1 ->
  subst2 (A @ 0) (A @ 1) (fun t0 t1 -> [x] A @ x {t0; t1})
    (p @ 0) a0 eq0
    (p @ 1) a1 eq1
    (bri x -> p @ x)

let subst_ends_eq : (A : [x] U<0> {*; *})
  (q : [x] A @ x {*; *})
  (p : [x] A @ x {*; *})
  (a0 : A @ 0) (eq0 : Id (A @ 0) (p @ 0) a0)
  (a1 : A @ 1) (eq1 : Id (A @ 1) (p @ 1) a1)
  -> ([x] Id (A @ x) (q @ x) (p @ x) {*; *})
  -> ([x] Id (A @ x) (q @ x) (subst_ends A p a0 eq0 a1 eq1 @ x) {*; *})
  =
  fun A q p ->
  based0_J (A @ 0) (p @ 0)
    (fun a0 eq0 ->
      (a1 : A @ 1) (eq1 : Id (A @ 1) (p @ 1) a1)
      -> ([x] Id (A @ x) (q @ x) (p @ x) {*; *})
      -> ([x] Id (A @ x) (q @ x) (subst_ends A p a0 eq0 a1 eq1 @ x) {*; *}))
    (based0_J (A @ 1) (p @ 1)
      (fun a1 eq1 ->
        ([x] Id (A @ x) (q @ x) (p @ x) {*; *})
        -> ([x] Id (A @ x) (q @ x) (subst_ends A p (p @ 0) (refl (p @ 0)) a1 eq1 @ x) {*; *}))
      (fun t -> t))

let subst2inv : (A : U<0>) (B : U<0>) (C : A -> B -> U<0>)
  (a0 : A) (a1 : A) (eqA : Id A a0 a1)
  (b0 : B) (b1 : B) (eqB : Id B b0 b1)
  -> (C a1 b1) -> C a0 b0
  =
  fun A B C a0 a1 eqA b0 b1 eqB ->
  subst2 A B C a1 a0 (symm A a0 a1 eqA) b1 b0 (symm B b0 b1 eqB)

let substinv_ends : (A : [x] U<0> {*; *}) (p : [x] A @ x {*; *})
  (a0 : A @ 0) (eq0 : Id (A @ 0) a0 (p @ 0))
  (a1 : A @ 1) (eq1 : Id (A @ 1) a1 (p @ 1))
  -> [x] A @ x {a0; a1}
  =
  fun A p a0 eq0 a1 eq1 ->
  subst2inv (A @ 0) (A @ 1) (fun t0 t1 -> [x] A @ x {t0; t1})
    a0 (p @ 0) eq0
    a1 (p @ 1) eq1
    (bri x -> p @ x)

let substinv_ends_eq : (A : [x] U<0> {*; *})
  (q : [x] A @ x {*; *})
  (p : [x] A @ x {*; *})
  (a0 : A @ 0) (eq0 : Id (A @ 0) a0 (p @ 0))
  (a1 : A @ 1) (eq1 : Id (A @ 1) a1 (p @ 1))
  -> ([x] Id (A @ x) (q @ x) (p @ x) {*; *})
  -> ([x] Id (A @ x) (q @ x) (substinv_ends A p a0 eq0 a1 eq1 @ x) {*; *})
  =
  fun A q p ->
  based1_J (A @ 0) (p @ 0)
    (fun a0 eq0 ->
      (a1 : A @ 1) (eq1 : Id (A @ 1) a1 (p @ 1))
      -> ([x] Id (A @ x) (q @ x) (p @ x) {*; *})
      -> ([x] Id (A @ x) (q @ x) (substinv_ends A p a0 eq0 a1 eq1 @ x) {*; *}))
    (based1_J (A @ 1) (p @ 1)
      (fun a1 eq1 ->
        ([x] Id (A @ x) (q @ x) (p @ x) {*; *})
        -> ([x] Id (A @ x) (q @ x) (substinv_ends A p (p @ 0) (refl (p @ 0)) a1 eq1 @ x) {*; *}))
      (fun t -> t))

let set_id_bridge_ends : (A : [x] U<0> {*; *})
  (p : [x] A @ x {*; *}) (q : [x] A @ x {*; *})
  (eq0 : Id (A @ 0) (p @ 0) (q @ 0)) (eq1 : Id (A @ 1) (p @ 1) (q @ 1))
  -> ([x] Id (A @ x) (p @ x) (q @ x) {*; *})
  -> ([x] Id (A @ x) (p @ x) (q @ x) {eq0; eq1})
  =
  fun A p q eq0 eq1 t ->
  subst_ends
    (bri x -> Id (A @ x) (p @ x) (q @ x))
    t
    eq0 (uip (A @ 0) (p @ 0) (q @ 0) (t @ 0) eq0)
    eq1 (uip (A @ 1) (p @ 1) (q @ 1) (t @ 1) eq1)
      
let cong : (A : U<0>) (B : U<0>) (f : A -> B) (a0 : A) (a1 : A)
  -> (Id A a0 a1) -> Id B (f a0) (f a1)
  =
  fun A B f a0 a1 eq ->
  match eq at a0 a1 _ -> Id B (f a0) (f a1) with
  | refl z -> refl (f z)

let cong_bapp : (A : [_] U<0> {*; *})
  (b0 : [x] A @ x {*; *}) (b1 : [x] A @ x {*; *})
  -> (Id ([x] A @ x {*; *}) b0 b1)
  -> [x] Id (A @ x) (b0 @ x) (b1 @ x) {*; *}
  =
  fun A b0 b1 eq ->
  match eq at c0 c1 _ -> [x] Id (A @ x) (c0 @ x) (c1 @ x) {*; *} with
  | refl c -> bri x -> refl (c @ x)

let lineext : (A : [x] U<0> {*; *})
  (p0 : [x] A @ x {*; *}) (p1 : [x] A @ x {*; *})
  -> ([x] Id (A @ x) (p0 @ x) (p1 @ x) {*; *})
  -> Id ([x] A @ x {*; *}) p0 p1
  =
  fun A p0 p1 q ->
  subst2 (A @ 0) (A @ 1)
    (fun a0 a1 ->
      (p1 : [x] A @ x {a0; a1})
      -> ([x] Id (A @ x) (p0 @ x) (p1 @ x) {*; *})
      -> Id ([x] A @ x {*; *}) p0 p1)
    (p0 @ 0) (p1 @ 0) (q @ 0)
    (p0 @ 1) (p1 @ 1) (q @ 1)
    (fun p1' q' -> briext (bri x -> A @ x) p0 p1' q')
    (bri x -> p1 @ x)
    q

let based0ext : (A : [x] U<0> {*; *})
  (p0 : [x] A @ x {*; *}) (p1 : [x] A @ x {p0 @ 0; *})
  -> ([x] Id (A @ x) (p0 @ x) (p1 @ x) {*; *})
  -> Id ([x] A @ x {p0 @ 0; *}) (bri x -> p0 @ x) p1
  =
  fun A p0 p1 q ->
  subst (A @ 1)
    (fun a1 ->
      (p1 : [x] A @ x {p0 @ 0; a1})
      -> ([x] Id (A @ x) (p0 @ x) (p1 @ x) {*; *})
      -> Id ([x] A @ x {p0 @ 0; *}) (bri x -> p0 @ x) p1)
    (p0 @ 1) (p1 @ 1) (q @ 1)
    (fun p1' q' -> briext (bri x -> A @ x) p0 p1' q')
    (bri x -> p1 @ x)
    q

let gelproj : (A : U<0>) (B : U<0>) (R : A -> B -> U<0>)
  (a : A) (b : B) -> [x] Gel x {A; B} (a b -> R a b) {a; b} -> R a b
  =
  fun A B R a b p ->
  ungel x : 2 -> p @ x at _ -> R a b with | gel r -> r

let gel_eta : (A : U<0>) (B : U<0>) (R : A -> B -> U<0>) (a : A) (b : B)
  (p : [x] Gel x {A; B} (a b -> R a b) {a; b})
  -> [x] Id (Gel x {A; B} (a b -> R a b)) (p @ x) (gel x {a; b} (gelproj A B R a b p)) {*; *}
  =
  fun A B R a b p ->
  ungel x : 2 -> p @ x at
  q -> [x] Id (Gel x {A; B} (a b -> R a b)) (q @ x) (gel x {a; b} (gelproj A B R a b q)) {*; *}
  with
  | gel r -> bri x -> refl (gel x {a;b} r)

--------------------------------------------------------------------------------
-- Definition of fibration
--------------------------------------------------------------------------------

let box : (t : bool) (c : cof) -> [x] U<0> {*; *} =
  fun t c -> bri x ->
  Gel x
    { if t at _ -> U<0> with | tt -> decode c | ff -> unit
    ; if t at _ -> U<0> with | tt -> unit | ff -> decode c
    }
    (_ _ -> unit)

let Filler : (G : U<0>) (A : G -> U<0>)
  (p : [_] G {*; *})
  (t : bool) (c : cof)
  (f : [x] (box t c @ x) -> A (p @ x) {*; *})
  -> U<0>
  =
  fun G A p t c f ->
  [x] (a : A (p @ x)) * (u : box t c @ x) -> Id (A (p @ x)) (f @ x u) a {*; *}

let is_fib : (G : U<0>) (A : G -> U<0>) -> U<1> =
  fun G A ->
  (p : [_] G {*; *})
  (t : bool) (c : cof)
  (f : [x] (box t c @ x) -> A (p @ x) {*; *})
  ->
  Filler G A p t c f

let comp0_path : (G : U<0>) (A : G -> U<0>) (fibA : is_fib G A)
  (p : [_] G {*; *}) (c : cof)
  (f : [x] (box ff c @ x) -> A (p @ x) {*; *})
  ->
  (q : [x] A (p @ x) {f @ 0 triv; *})
  * (u : decode c) -> [x] Id (A (p @ x)) (f @ x (gel x {triv; u} triv)) (q @ x) {*; *}
  =
  fun G A fibA p c f ->
  substinv
    (A (p @ 0))
    (fun a -> 
      (q : [x] A (p @ x) {a; *})
      * (u : decode c) -> [x] Id (A (p @ x)) (f @ x (gel x {triv; u} triv)) (q @ x) {*; *})
    (f @ 0 triv)
    (fst (fibA p ff c f @ 0))
    (snd (fibA p ff c f @ 0) triv)
    < bri x -> fst (fibA p ff c f @ x)
    , fun u -> bri x -> snd (fibA p ff c f @ x) (gel x {triv; u} triv)
    >

--------------------------------------------------------------------------------
-- Forming open boxes
--------------------------------------------------------------------------------

let end_ty : ([x] U<0> {*; *}) -> bool -> U<0> =
  fun A -> fun t ->
  if t at _ -> U<0> with | tt -> A @ 1 | ff -> A @ 0

let adjoin_bdy : (A : [x] U<0> {*; *}) (c : cof)
  (f0 : A @ 0) (f1 : A @ 1)
  (f : (decode c) -> [x] A @ x {f0; f1})
  -> [x] (decode (cof_bdy c @ x)) -> A @ x {fun _ -> f0; fun _ -> f1}
  =
  fun A c f0 f1 f -> bri x -> fun u01 ->
  extent x of u01 in x -> decode (cof_bdy c @ x) at x _ -> A @ x with
  | _ -> f0
  | _ -> f1
  | _ _ q x ->
    (ungel x : 2 -> q @ x at _ -> [x] A @ x {f0; f1} with
     | gel u -> f u)
    @ x

let adjoin_cap0 : (A : [x] U<0> {*; *}) (c : cof) (a0 : A @ 0)
  (f : (decode c) -> [x] A @ x {a0; *})
  -> [x] (box ff c @ x) -> A @ x {fun _ -> a0; *}
  =
  fun A c a0 f -> bri x -> fun u0 ->
  extent x of u0 in x -> Gel x {unit; decode c} (_ _ -> unit) at x _ -> A @ x with
  | _ -> a0
  | u -> f u @ 1
  | _ u _ x -> f u @ x

let adjoin_cap1 : (A : [x] U<0> {*; *}) (c : cof) (a1 : A @ 1)
  (f : (decode c) -> [x] A @ x {*; a1})
  -> [x] (box tt c @ x) -> A @ x {*; fun _ -> a1}
  =
  fun A c a1 f -> bri x -> fun u1 ->
  extent x of u1 in x -> Gel x {decode c; unit} (_ _ -> unit) at x _ -> A @ x with
  | u -> f u @ 0
  | _ -> a1
  | u _ _ x -> f u @ x


--------------------------------------------------------------------------------
-- Fibrancy (hcom)
--------------------------------------------------------------------------------

let is_fibrant : U<0> -> U<1> =
  fun A ->
  (t : bool) (c : cof)
  (f : [x] (box t c @ x) -> A {*; *})
  ->
  Filler unit (fun _ -> A) (bri _ -> triv) t c f

let fibrant_to_fib : (A : U<0>) -> (is_fibrant A) -> (G : U<0>) -> is_fib G (fun _ -> A) =
  fun A fibA G p t c f ->
  fibA t c f

--------------------------------------------------------------------------------
-- Coercion and squeezing
--------------------------------------------------------------------------------

let empty_box : (A : [x] U<0> {*; *}) (t : bool)
  -> (end_ty A t) -> [x] (box t cof_empty @ x) -> A @ x {*; *}
  =
  fun A t ->
  if t at t -> (end_ty A t) -> [x] (box t cof_empty @ x) -> A @ x {*; *} with
  | tt -> fun a1 -> bri x -> fun f ->
    extent x of f in x -> box tt cof_empty @ x at x _ -> A @ x with
    | no -> abort_empty no (A @ 0)
    | _ -> a1
    | no _ _ x -> abort_empty no ([x] A @ x {abort_empty no (A @ 0); a1}) @ x
  | ff -> fun a0 -> bri x -> fun f ->
    extent x of f in x -> box ff cof_empty @ x at x _ -> A @ x with
    | _ -> a0
    | no -> abort_empty no (A @ 1)
    | _ no _ x -> abort_empty no ([x] A @ x {a0; abort_empty no (A @ 1)}) @ x

let coe01 : (G : U<0>) (A : G -> U<0>) (fibA : is_fib G A) (p : [_] G {*; *})
  -> (A (p @ 0)) -> A (p @ 1)
  =
  fun G A fibA p a0 ->
  fst (fibA p ff cof_empty (empty_box (bri x -> A (p @ x)) ff a0) @ 1)

let coe0 : (G : U<0>) (A : G -> U<0>) (fibA : is_fib G A) (p : [_] G {*; *})
  -> (a0 : A (p @ 0)) -> [y] A (p @ y) {a0; coe01 G A fibA p a0}
  =
  fun G A fibA p a0 ->
  substinv
   (A (p @ 0))
   (fun a -> [y] A (p @ y) {a; coe01 G A fibA p a0})
   a0
   (fst (fibA p ff cof_empty (empty_box (bri x -> A (p @ x)) ff a0) @ 0))
   (snd (fibA p ff cof_empty (empty_box (bri x -> A (p @ x)) ff a0) @ 0) triv)
   (bri y -> fst (fibA p ff cof_empty (empty_box (bri x -> A (p @ x)) ff a0) @ y))

let coe10 : (G : U<0>) (A : G -> U<0>) (fibA : is_fib G A) (p : [_] G {*; *})
  -> (A (p @ 1)) -> A (p @ 0)
  =
  fun G A fibA p a1 ->
  fst (fibA p tt cof_empty (empty_box (bri x -> A (p @ x)) tt a1) @ 0)

let coe1 : (G : U<0>) (A : G -> U<0>) (fibA : is_fib G A) (p : [_] G {*; *})
  (a1 : A (p @ 1)) -> [y] A (p @ y) {coe10 G A fibA p a1; a1}
  =
  fun G A fibA p a1 ->
  substinv
   (A (p @ 1))
   (fun a -> [y] A (p @ y) {coe10 G A fibA p a1; a})
   a1
   (fst (fibA p tt cof_empty (empty_box (bri x -> A (p @ x)) tt a1) @ 1))
   (snd (fibA p tt cof_empty (empty_box (bri x -> A (p @ x)) tt a1) @ 1) triv)
   (bri y -> fst (fibA p tt cof_empty (empty_box (bri x -> A (p @ x)) tt a1) @ y))

let squeeze0Fill : (G : U<0>) (A : G -> U<0>) (fibA : is_fib G A) (p : [_] G {*; *})
  (a : [x] A (p @ x) {*; *})
  -> [y] [x] A (p @ y) {a @ y; coe1 G A fibA p (a @ 1) @ y} {*; bri _ -> a @ 1}
  =
  fun G A fibA p a ->
  let c : [x] cof {*; *} = cof_bdy cof_empty
  in
  let tube : [x] (decode (c @ x)) -> [y] A (p @ y) {*; a @ 1} {*; *} =
    adjoin_bdy
      (bri _ -> [y] A (p @ y) {*; a @ 1})
      cof_empty
      (bri y -> a @ y)
      (coe1 G A fibA p (a @ 1))
      (fun no -> abort_empty no
        ([_] [y] A (p @ y) {*; a @ 1} {bri y -> a @ y; coe1 G A fibA p (a @ 1)}))
  in
  let open_box : [x] [y] (box tt (c @ x) @ y) -> A (p @ y) {*; fun _ -> a @ 1} {*; *} =
    bri x ->
    adjoin_cap1 (bri y -> A (p @ y)) (c @ x) (a @ 1) (tube @ x)
  in
  let comp : [x] Filler G A p tt (c @ x) (bri y -> open_box @ x @ y) {*; *} =
    bri x -> fibA p tt (c @ x) (open_box @ x)
  in
  substinv
    ([x] [y] (box tt (c @ x) @ y) -> A (p @ y) {*; *} {*; *})
    (fun b ->
      [y] [x] A (p @ y) {b @ 0 @ y (gel y {triv; triv} triv); b @ 1 @ y (gel y {triv; triv} triv)}
        {*; bri x -> b @ x @ 1 triv})
    (bri x -> bri y -> fun u -> open_box @ x @ y u)
    (bri x -> bri y -> fun _ -> fst (comp @ x @ y))
    (lineext (bri x -> [y] (box tt (c @ x) @ y) -> A (p @ y) {*; *})
      (bri x -> bri y -> fun u -> open_box @ x @ y u)
      (bri x -> bri y -> fun _ -> fst (comp @ x @ y))
      (bri x -> lineext (bri y -> (box tt (c @ x) @ y) -> A (p @ y))
        (bri y -> fun u -> open_box @ x @ y u)
        (bri y -> fun _ -> fst (comp @ x @ y))
        (bri y -> funext (box tt (c @ x) @ y) (fun _ -> A (p @ y))
          (fun u -> open_box @ x @ y u)
          (fun _ -> fst (comp @ x @ y))
          (snd (comp @ x @ y)))))
    (bri y -> bri x -> fst (comp @ x @ y))
    
let squeeze0 : (G : U<0>) (A : G -> U<0>) (fibA : is_fib G A) (p : [_] G {*; *})
  (a : [x] A (p @ x) {*; *}) -> [x] A (p @ 0) {a @ 0; coe10 G A fibA p (a @ 1)}
  =
  fun G A fibA p a -> squeeze0Fill G A fibA p a @ 0

let squeeze : (G : U<0>) (A : G -> U<0>) (fibA : is_fib G A) (p : [_] G {*; *})
  (a : [x] A (p @ x) {*; *})
  -> [x] [y] A (p @ y) {*; *} {coe0 G A fibA p (a @ 0); coe1 G A fibA p (a @ 1)}
  =
  fun G A fibA p a ->
  let c : [x] cof {*; *} = cof_bdy cof_empty
  in
  let tube : [x] (decode (c @ x)) -> [y] A (p @ y) {squeeze0 G A fibA p a @ x; *} {*; *} =
    bri x ->
    adjoin_bdy
      (bri x -> [y] A (p @ y) {squeeze0 G A fibA p a @ x; *})
      cof_empty
      (coe0 G A fibA p (a @ 0))
      (coe1 G A fibA p (a @ 1))
      (fun no -> abort_empty no
        ([x] [y] A (p @ y) {squeeze0 G A fibA p a @ x; *}
         {coe0 G A fibA p (a @ 0); coe1 G A fibA p (a @ 1)}))
      @ x
  in
  let open_box : [x] [y] (box ff (c @ x) @ y) -> A (p @ y) {fun _ -> squeeze0 G A fibA p a @ x; *} {*; *} =
    bri x ->
    adjoin_cap0
      (bri y -> A (p @ y))
      (c @ x)
      (squeeze0 G A fibA p a @ x)
      (tube @ x)
  in
  let comp : [x] Filler G A p ff (c @ x) (open_box @ x) {*; *} =
    bri x -> fibA p ff (c @ x) (open_box @ x)
  in
  let flipped : [y] [x] A (p @ y) {coe0 G A fibA p (a @ 0) @ y; coe1 G A fibA p (a @ 1) @ y} {*; *} =
     bri y ->
     substinv_ends (bri _ -> A (p @ y))
      (bri x -> fst (comp @ x @ y))
      (coe0 G A fibA p (a @ 0) @ y)
      (snd (comp @ 0 @ y) (gel y {triv; triv} triv))
      (coe1 G A fibA p (a @ 1) @ y)
      (snd (comp @ 1 @ y) (gel y {triv; triv} triv))
  in
  bri x y -> flipped @ y @ x

let coe : (G : U<0>) (A : G -> U<0>) (fibA : is_fib G A) (p : [_] G {*; *})
  -> [x] (A (p @ x)) -> [y] A (p @ y) {*; *} {coe0 G A fibA p; coe1 G A fibA p}
  =
  fun G A fibA p -> bri x -> fun a ->
  extent x of a in x -> A (p @ x) at _ _ -> [y] A (p @ y) {*; *} with
  | a0 -> coe0 G A fibA p a0
  | a1 -> coe1 G A fibA p a1
  | a0 a1 q x -> squeeze G A fibA p (bri x -> q @ x) @ x

--------------------------------------------------------------------------------
-- Fibrations are closed under sigma-types
--------------------------------------------------------------------------------

let Sigma : (G : U<0>) (A : G -> U<0>) (B : ((g : G) * A g) -> U<0>) -> G -> U<0> =
  fun G A B g -> (a : A g) * B <g, a>

let sigmaEq : (A : U<0>) (B : A -> U<0>)
  (s0 : (a : A) * B a) (s1 : (a : A) * B a)
  (eqA : Id A (fst s0) (fst s1))
  -> (Id (B (fst s1)) (subst A B (fst s0) (fst s1) eqA (snd s0)) (snd s1))
  -> Id ((a : A) * B a) s0 s1
  =
  fun A B s0 s1 eqA eqB ->
  (match eqA at
     a0 a1 eqA ->
     (b0 : B a0) (b1 : B a1)
     -> (Id (B a1) (subst A B a0 a1 eqA b0) b1)
     -> Id ((a : A) * B a) <a0, b0> <a1, b1>
   with
   | refl a -> cong (B a) ((a : A) * B a) (fun b -> <a, b>))
  (snd s0) (snd s1) eqB

let fibSigma : (G : U<0>) (A : G -> U<0>) (B : ((g : G) * A g) -> U<0>)
  -> (is_fib G A) -> (is_fib ((g : G) * A g) B) -> is_fib G (Sigma G A B)
  =
  fun G A B fibA fibB ->
  fun p t c f ->
  let fA : [x] (box t c @ x) -> A (p @ x) {*; *} =
    bri x -> fun u -> fst (f @ x u)
  in
  let cA : [x] (a : A (p @ x)) * (u : box t c @ x) -> Id (A (p @ x)) (fA @ x u) a {*; *}
    =
    fibA p t c fA
  in
  let q : [x] (g : G) * A g {*; *} =
    bri x -> <p @ x, fst (cA @ x)>
  in
  let fB : [x] (box t c @ x) -> B (q @ x) {*; *} =
    bri x -> fun u ->
    subst (A (p @ x)) (fun a -> B <p @ x, a>)
      (fst (f @ x u)) (fst (cA @ x)) (snd (cA @ x) u)
      (snd (f @ x u))
  in
  let cB : [x] (cb : B (q @ x)) * (u : box t c @ x) -> Id (B (q @ x)) (fB @ x u) cb {*; *}
    =
    fibB q t c fB
  in
  bri x ->
  < <fst (cA @ x), fst (cB @ x)>
  , fun u ->
    sigmaEq
      (A (p @ x))
      (fun a -> B <p @ x, a>)
      (f @ x u)
      (<fst (cA @ x), fst (cB @ x)>)
      (snd (cA @ x) u)
      (snd (cB @ x) u)
  >

--------------------------------------------------------------------------------
-- Fibrations are closed under pi-types
--------------------------------------------------------------------------------

let Pi : (G : U<0>) (A : G -> U<0>) (B : ((g : G) * A g) -> U<0>) -> G -> U<0> =
  fun G A B g -> (a : A g) -> B <g, a>

let fibPiFrom0 : (G : U<0>) (A : G -> U<0>) (B : ((g : G) * A g) -> U<0>)
  -> (is_fib G A) -> (is_fib ((g : G) * A g) B)
  -> (p : [_] G {*; *}) (c : cof)
  (f : [x] (box ff c @ x) -> (Pi G A B) (p @ x) {*; *})
  ->
  [x] (a : Pi G A B (p @ x)) * (u : box ff c @ x) -> Id (Pi G A B (p @ x)) (f @ x u) a {*; *}
  =
  fun G A B fibA fibB ->
  fun p c f ->
  let from1 : (a1 : A (p @ 1)) -> [x] A (p @ x) {*; a1} = coe1 G A fibA p
  in
  let compB1 : (a1 : A (p @ 1)) ->
    (q : [x] B <p @ x, from1 a1 @ x> {f @ 0 triv (from1 a1 @ 0); *})
    * (u : decode c) ->
      [x] Id (B <p @ x, from1 a1 @ x>) (f @ x (gel x {triv; u} triv) (from1 a1 @ x)) (q @ x) {*; *}
    =
    fun a1 ->
    comp0_path ((g : G) * A g) B fibB
      (bri y -> <p @ y, from1 a1 @ y>) c (bri y -> fun u -> f @ y u (from1 a1 @ y))
  in
  let sqz : (q : [x] A (p @ x) {*; *})
    -> [x] [z] A (p @ x) {q @ x; from1 (q @ 1) @ x} {*; bri _ -> q @ 1}
    =
    fun a -> squeeze0Fill G A fibA p a
  in
  let tube_part0 : (q : [x] A (p @ x) {*; *}) (u : decode c)
    -> (r : [z] [x] B <p @ x, sqz q @ x @ z> {f @ 0 triv (sqz q @ 0 @ z); fst (compB1 (q @ 1)) @ 1}
            {*; bri x -> fst (compB1 (q @ 1)) @ x})
       * [x] Id (B <p @ x, q @ x>) (f @ x (gel x {triv; u} triv) (q @ x)) (r @ 0 @ x) {*; *}
    =
    fun q u -> 
    subst
      ([x] B <p @ x, from1 (q @ 1) @ x> {f @ 0 triv (from1 (q @ 1) @ 0); *})
      (fun t ->
        (r : [z] [x] B <p @ x, sqz q @ x @ z> {f @ 0 triv (sqz q @ 0 @ z); t @ 1} {*; bri x -> t @ x})
        * [x] Id (B <p @ x, q @ x>) (f @ x (gel x {triv; u} triv) (q @ x)) (r @ 0 @ x) {*; *})
      (bri x -> f @ x (gel x {triv; u} triv) (from1 (q @ 1) @ x))
      (fst (compB1 (q @ 1)))
      (based0ext (bri x -> B <p @ x, from1 (q @ 1) @ x>)
        (bri x -> f @ x (gel x {triv; u} triv) (from1 (q @ 1) @ x))
        (fst (compB1 (q @ 1)))
        (snd (compB1 (q @ 1)) u))
      < bri z -> bri x -> f @ x (gel x {triv; u} triv) (sqz q @ x @ z)
      , bri x -> refl (f @ x (gel x {triv; u} triv) (q @ x))
      >
  in
  let tube_part1 : (q : [x] A (p @ x) {*; *})
    -> [x] (decode (cof_bdy c @ x)) -> [z] B <p @ x, sqz q @ x @ z> {*; fst (compB1 (q @ 1)) @ x}
       {fun _ -> bri z -> f @ 0 triv (sqz q @ 0 @ z); fun _ -> bri _ -> fst (compB1 (q @ 1)) @ 1}
    =
    fun q ->
    adjoin_bdy
      (bri x -> [z] B <p @ x, sqz q @ x @ z> {*; fst (compB1 (q @ 1)) @ x})
      c
      (bri z -> f @ 0 triv (sqz q @ 0 @ z))
      (bri _ -> fst (compB1 (q @ 1)) @ 1)
      (fun u -> bri x -> bri z -> fst (tube_part0 q u) @ z @ x)
  in
  let open : (q : [x] A (p @ x) {*; *})
    -> [x] [z] (box tt (cof_bdy c @ x) @ z) -> B <p @ x, sqz q @ x @ z>
           {*; fun _ -> fst (compB1 (q @ 1)) @ x}
       {*; *}
    =
    fun q -> bri x ->
    adjoin_cap1
      (bri z -> B <p @ x, sqz q @ x @ z>)
      (cof_bdy c @ x)
      (fst (compB1 (q @ 1)) @ x)
      (fun u -> bri z -> tube_part1 q @ x u @ z)
  in
  let compB : (q : [x] A (p @ x) {*; *})
    -> [x] (b : B <p @ x, q @ x>)
           * (u : decode (cof_bdy c @ x)) -> Id (B <p @ x, q @ x>) (open q @ x @ 0 u) b
       {*; *}
    =
    fun q -> bri x ->
    fibB
      (bri z -> <p @ x, sqz q @ x @ z>)
      tt
      (cof_bdy c @ x)
      (bri z -> fun u -> open q @ x @ z u)
      @ 0
  in
  let compB_path : (q : [x] A (p @ x) {*; *})
    -> [x] B <p @ x, q @ x> {f @ 0 triv (q @ 0); fst (compB1 (q @ 1)) @ 1}
    =
    fun q ->
    substinv_ends (bri x -> B <p @ x, q @ x>)
      (bri x -> fst (compB q @ x))
      (f @ 0 triv (q @ 0))
      (snd (compB q @ 0) triv)
      (fst (compB1 (q @ 1)) @ 1)
      (snd (compB q @ 1) triv)
  in
  let result : [x] Pi G A B (p @ x) {*; *} =
    bri x -> fun a ->
    extent x of a in x -> A (p @ x) at x a -> B <p @ x, a> with
    | a0 -> f @ 0 triv a0
    | a1 -> fst (compB1 a1) @ 1
    | a0 a1 q x -> compB_path q @ x
  in
  bri x ->
  < result @ x
  , fun u ->
    funext (A (p @ x)) (fun a -> B <p @ x, a>)
      (f @ x u)
      (result @ x)
      (fun a ->
        extent x of <u,a> in
        x -> (box ff c @ x) * A (p @ x) at
        x ua -> Id (B <p @ x, snd ua>) (f @ x (fst ua) (snd ua)) (result @ x (snd ua)) with
        | ua0 -> refl (f @ 0 triv (snd ua0))
        | ua1 -> snd (compB1 (snd ua1)) (fst ua1) @ 1
        | ua0 ua1 ua x ->
          set_id_bridge_ends
            (bri x -> B <p @ x, snd (ua @ x)>)
            (bri x -> f @ x (fst (ua @ x)) (snd (ua @ x)))
            (bri x -> result @ x (snd (ua @ x)))
            (refl (f @ 0 triv (snd ua0)))
            (snd (compB1 (snd ua1)) (fst ua1) @ 1)
            (substinv_ends_eq
              (bri x -> B <p @ x, snd (ua @ x)>)
              (bri x -> f @ x (fst (ua @ x)) (snd (ua @ x)))
              (bri x -> fst (compB (bri x -> snd (ua @ x)) @ x))
              (f @ 0 triv (snd ua0))
              (snd (compB (bri x -> snd (ua @ x)) @ 0) triv)
              (fst (compB1 (snd ua1)) @ 1)
              (snd (compB (bri x -> snd (ua @ x)) @ 1) triv)
              (bri x ->
                trans
                  (B <p @ x, snd (ua @ x)>)
                  (f @ x (fst (ua @ x)) (snd (ua @ x)))
                  (f @ x (gel x {triv; fst ua1} triv) (snd (ua @ x)))
                  (fst (compB (bri x -> snd (ua @ x)) @ x))
                  (cong (box ff c @ x) (B <p @ x, snd (ua @ x)>)
                    (fun u -> f @ x u (snd (ua @ x)))
                    (fst (ua @ x))
                    (gel x {triv; fst ua1} triv)
                    (gel_eta unit (decode c) (fun _ _ -> unit) triv (fst ua1) (bri x -> fst (ua @ x)) @ x))
                  (trans
                    (B <p @ x, snd (ua @ x)>)
                    (f @ x (gel x {triv; fst ua1} triv) (snd (ua @ x)))
                    (fst (tube_part0 (bri x -> snd (ua @ x)) (fst ua1)) @ 0 @ x)
                    (fst (compB (bri x -> snd (ua @ x)) @ x))
                    (snd (tube_part0 (bri x -> snd (ua @ x)) (fst ua1)) @ x)
                    (snd (compB (bri x -> snd (ua @ x)) @ x) (gel x {triv; triv} (fst ua1))))))
            @ x)
  >

--------------------------------------------------------------------------------
-- Experiment with a circle. We postulate a "candidate circle" type that has a
-- point and loop and is fibrant. It is a non-trivial question whether there
-- exists a term that could serve as the reduct of a circle-elimination applied
-- to the loop. We construct such a term.
--------------------------------------------------------------------------------

postulate circle : U<0>
postulate base : circle
postulate loop : [x] circle {base; base}
postulate circle_is_fibrant : is_fibrant circle

-- This is a standard construction in cartesian cubical type theory and could be defined in the
-- same way here. Let's take it for granted.
postulate connection_and : (A : U<0>) (fibA : is_fibrant A) (p : [x] A {*; *})
  -> [x] [y] A {p @ 0; p @ x} {bri _ -> p @ 0; bri y -> p @ y}

postulate connectiond_and : (G : U<0>) (fibG : is_fibrant G) (p : [x] G {*; *})
  (A : G -> U<0>) (fibA : is_fib G A) (q : [x] A (p @ x) {*; *})
  -> [x] [y] A (connection_and G fibG p @ x @ y) {q @ 0; q @ x} {bri _ -> q @ 0; bri y -> q @ y}

let diagonald_filler : (G : U<0>) (fibG : is_fibrant G) (p : [x] G {*; *})
  (A : [x] G -> U<0> {*; *}) (fibA : [x] is_fib G (A @ x) {*; *})
  (q : [x] [y] A @ x (p @ y) {*; *} {*; *})
  -> [z] [x] A @ x (connection_and G fibG p @ x @ z) {q @ 0 @ 0; q @ 1 @ z} {bri x -> q @ x @ 0; *}
  =
  fun G fibG p A fibA q ->
  let g : [x] [y] G {*; *} {*; *} =
    connection_and G fibG p
  in
  let tube : [x] (decode (cof_bdy cof_empty @ x)) -> [y] A @ x (g @ x @ y) {q @ x @ 0; *} {*; *} =
    adjoin_bdy
      (bri x -> [y] A @ x (g @ x @ y) {q @ x @ 0; *})
      cof_empty
      (bri _ -> q @ 0 @ 0)
      (bri y -> q @ 1 @ y)
      (fun no ->
        abort_empty no
          ([x] [y] A @ x (g @ x @ y) {q @ x @ 0; *} {bri _ -> q @ 0 @ 0; bri y -> q @ 1 @ y}))
  in
  let open : [x] [y] (box ff (cof_bdy cof_empty @ x) @ y) -> A @ x (g @ x @ y)  {fun _ -> q @ x @ 0; *} {*; *} =
    bri x ->
    adjoin_cap0
      (bri y -> A @ x (g @ x @ y))
      (cof_bdy cof_empty @ x)
      (q @ x @ 0)
      (tube @ x)
  in
  let filler : [x] Filler G (A @ x) (bri y -> g @ x @ y) ff (cof_bdy cof_empty @ x) (open @ x) {*; *} =
    bri x -> (fibA @ x) (g @ x) ff (cof_bdy cof_empty @ x) (open @ x)
  in
  substinv
    ([x] [y] (box ff (cof_bdy cof_empty @ x) @ y) -> A @ x (g @ x @ y) {*; *} {*; *})
    (fun r ->
       [z] [x] A @ x (g @ x @ z)
           {r @ 0 @ z (gel z {triv; triv} triv); r @ 1 @ z (gel z {triv; triv} triv)}
       {bri x -> r @ x @ 0 triv; *})
    (bri x y -> fun u -> open @ x @ y u)
    (bri x y -> fun _ -> fst (filler @ x @ y))
    (lineext
      (bri x -> [y] (box ff (cof_bdy cof_empty @ x) @ y) -> A @ x (g @ x @ y) {*; *})
      (bri x y -> fun u -> open @ x @ y u)
      (bri x y -> fun _ -> fst (filler @ x @ y))
      (bri x -> lineext
        (bri y -> (box ff (cof_bdy cof_empty @ x) @ y) -> A @ x (g @ x @ y))
        (bri y -> fun u -> open @ x @ y u)
        (bri y -> fun _ -> fst (filler @ x @ y))
        (bri y -> funext
          (box ff (cof_bdy cof_empty @ x) @ y)
          (fun _ -> A @ x (g @ x @ y))
          (fun u -> open @ x @ y u)
          (fun _ -> fst (filler @ x @ y))
          (fun u -> snd (filler @ x @ y) u))))
    (bri z x -> fst (filler @ x @ z))

let diagonald : (G : U<0>) (fibG : is_fibrant G) (p : [x] G {*; *})
  (A : [x] G -> U<0> {*; *}) (fibA : [x] is_fib G (A @ x) {*; *})
  (q : [x] [y] A @ x (p @ y) {*; *} {*; *})
  -> [x] A @ x (p @ x) {q @ 0 @ 0; q @ 1 @ 1}
  =
  fun G fibG p A fibA q -> diagonald_filler G fibG p A fibA q @ 1

let diagonald_beta : (G : U<0>) (fibG : is_fibrant G) (p : [x] G {*; *})
  (A : G -> U<0>) (fibA : is_fib G A) (q : [y] A (p @ y) {*; *})
  -> [z] [x] A (p @ x) {q @ 0; q @ 1}
     {diagonald G fibG p (bri _ -> A) (bri _ -> fibA) (bri _ -> q); bri x -> q @ x}
  =
  fun G fibG p A fibA q ->
  let g : [x] [y] G {*; *} {*; *} =
    connection_and G fibG p
  in
  let tube0 : [x] (decode (cof_bdy cof_empty @ x)) -> [y] A (g @ x @ y) {q @ 0; *} {*; *} =
    adjoin_bdy
      (bri x -> [y] A (g @ x @ y) {q @ 0; *})
      cof_empty
      (bri _ -> q @ 0)
      (bri y -> q @ y)
      (fun no ->
        abort_empty no
          ([x] [y] A (g @ x @ y) {q @ 0; *} {bri _ -> q @ 0; bri y -> q @ y}))
  in
  let tube1_ty : [x] U<0> {*; *} =
    bri x ->
    [z] [y] A (g @ x @ y) {q @ 0; *}
    {bri y -> diagonald_filler G fibG p (bri _ -> A) (bri _ -> fibA) (bri _ -> q) @ y @ x;
     bri y -> connectiond_and G fibG p A fibA q @ x @ y}
  in
  let tube1 : [x] [z] (decode (cof_bdy (cof_bdy cof_empty @ x) @ z)) -> [y] A (g @ x @ y) {q @ 0; *} {*; *} {*; *} =
    bri x ->
    adjoin_bdy
      (bri _ -> [y] A (g @ x @ y) {q @ 0; *})
      (cof_bdy cof_empty @ x)
      (bri y -> diagonald_filler G fibG p (bri _ -> A) (bri _ -> fibA) (bri _ -> q) @ y @ x)
      (bri y -> connectiond_and G fibG p A fibA q @ x @ y)
      (fun u ->
        extent x of u in
        x -> decode (cof_bdy cof_empty @ x) at
        x _ -> tube1_ty @ x with
        | u0 -> bri z -> tube0 @ 0 u0
        | u1 -> bri z -> tube0 @ 1 u1
        | u0 u1 r x ->
          abort_empty
            (gelproj unit unit (fun _ _ -> decode cof_empty) u0 u1 r)
            ([x] tube1_ty @ x {bri _ -> tube0 @ 0 u0; bri _ -> tube0 @ 1 u1})
            @ x)
  in
  let open : [x] [z] [y] (box ff (cof_bdy (cof_bdy cof_empty @ x) @ z) @ y) -> A (g @ x @ y) {*; *} {*; *} {*; *} =
    bri x z ->
    adjoin_cap0
      (bri y -> A (g @ x @ y))
      (cof_bdy (cof_bdy cof_empty @ x) @ z)
      (q @ 0)
      (tube1 @ x @ z)
  in
  substinv
    ([x] [z] (decode (cof_bdy (cof_bdy cof_empty @ x) @ z)) -> A (p @ x) {*; *} {*; *})
    (fun r ->
      [z] [x] A (p @ x) {r @ 0 @ z (gel z {triv; triv} triv); r @ 1 @ z (gel z {triv; triv} triv)}
      {bri x -> r @ x @ 0 triv; bri x -> r @ x @ 1 triv})
    (bri x z -> open @ x @ z @ 1)
    (bri x z -> fun _ -> fst (fibA (g @ x) ff (cof_bdy (cof_bdy cof_empty @ x) @ z) (open @ x @ z) @ 1))
    (lineext
      (bri x -> [z] (decode (cof_bdy (cof_bdy cof_empty @ x) @ z)) -> A (p @ x) {*; *})
      (bri x z -> open @ x @ z @ 1)
      (bri x z -> fun _ -> fst (fibA (g @ x) ff (cof_bdy (cof_bdy cof_empty @ x) @ z) (open @ x @ z) @ 1))
      (bri x -> lineext
        (bri z -> (decode (cof_bdy (cof_bdy cof_empty @ x) @ z)) -> A (p @ x))
        (bri z -> open @ x @ z @ 1)
        (bri z -> fun _ -> fst (fibA (g @ x) ff (cof_bdy (cof_bdy cof_empty @ x) @ z) (open @ x @ z) @ 1))
        (bri z -> funext
          (decode (cof_bdy (cof_bdy cof_empty @ x) @ z))
          (fun _ -> A (p @ x))
          (open @ x @ z @ 1)
          (fun _ -> fst (fibA (g @ x) ff (cof_bdy (cof_bdy cof_empty @ x) @ z) (open @ x @ z) @ 1))
          (fun u -> snd (fibA (g @ x) ff (cof_bdy (cof_bdy cof_empty @ x) @ z) (open @ x @ z) @ 1) u))))
    (bri z x -> fst (fibA (g @ x) ff (cof_bdy (cof_bdy cof_empty @ x) @ z) (open @ x @ z) @ 1))

-- [circle_elim_loop @ x A fibA b l] is the term to which the eliminator should reduce
-- when applied to [loop @ x]. What makes defining this term non-trivial is that the dimension
-- x is not guaranteed to be apart from A, fibA, b, or l; in particular, the application l @ x
-- is not defined.
let circle_elim_loop :
  [x] (A : circle -> U<0>) (fibA : is_fib circle A) (b : A base) (l : [y] A (loop @ y) {b; b}) -> A (loop @ x)
  {fun A fibA b l -> b; fun A fibA b l -> b}
  =
  bri x -> fun A fibA b l ->
  extent x of <A, <fibA, <b, l>>> in
  x -> (A : circle -> U<0>) * (fibA : is_fib circle A) * (b : A base) * [y] A (loop @ y) {b; b} at
  x s -> fst s (loop @ x) with
  | s0 -> fst (snd (snd s0))
  | s1 -> fst (snd (snd s1))
  | s0 s1 s x ->
    diagonald circle circle_is_fibrant loop
      (bri x -> fst (s @ x))
      (bri x -> fst (snd (s @ x)))
      (bri x -> snd (snd (snd (s @ x))))
      @ x

-- When A, fibA, b, and l /are/ apart from x, [circle_elim_loop @ x A fibA b l] is equal to
-- [l @ x] up to a path. This is what is needed for the "circle" to be a circle in the sense
-- of the HoTT book, although it is weaker than the strict equality we can achieve in
-- structural cubical type theory.
let circle_elim_loop_beta :
  (A : circle -> U<0>) (fibA : is_fib circle A) (b : A base) (l : [y] A (loop @ y) {b; b})
  -> [y] [x] A (loop @ x) {b; b} {bri x -> circle_elim_loop @ x A fibA b l; l}
  =
  fun A fibA b l -> diagonald_beta circle circle_is_fibrant loop A fibA l

--------------------------------------------------------------------------------
-- hcom + coe + "squeeze square" => com
--------------------------------------------------------------------------------

let is_fib0 : (G : U<0>) (A : G -> U<0>) -> U<1> =
  fun G A ->
  (p : [_] G {*; *}) (c : cof)
  (f : [x] (box ff c @ x) -> A (p @ x) {*; *})
  ->
  Filler G A p ff c f

let has_coe0 : (G : U<0>) (A : G -> U<0>) -> U<1> =
  fun G A ->
  (p : [x] G {*; *}) (a : A (p @ 0)) -> [x] A (p @ x) {a; *}

let has_coe1 : (G : U<0>) (A : G -> U<0>) -> U<1> =
  fun G A ->
  (p : [x] G {*; *}) (a : A (p @ 1)) -> [x] A (p @ x) {*; a}

let has_square0 : (G : U<0>) (A : G -> U<0>) -> (has_coe0 G A) -> U<1> =
  fun G A coeA0 ->
  (p : [_] G {*; *}) (q : [x] A (p @ x) {*; *})
  -> [y] [x] A (p @ x) {q @ 0; *} {coeA0 p (q @ 0); bri x -> q @ x}

let has_square1 : (G : U<0>) (A : G -> U<0>) -> (has_coe1 G A) -> U<1> =
  fun G A coeA1 ->
  (p : [_] G {*; *}) (q : [x] A (p @ x) {*; *})
  -> [y] [x] A (p @ x) {*; q @ 1} {bri x -> q @ x; coeA1 p (q @ 1)}

let hcom_and_coe_to_fib : (G : U<0>) (A : G -> U<0>)
  (fib : (g : G) -> is_fibrant (A g))
  (coe0 : has_coe0 G A) (sq0 : has_square0 G A coe0)
  -> is_fib0 G A
  =
  fun G A fib coe0 sq0 ->
  fun p c f ->
  let tube_step0 : (decode c) -> [y] [x] A (p @ x) {f @ 0 triv; *} {coe0 p (f @ 0 triv); *} =
    fun u -> sq0 p (bri y -> f @ y (gel y {triv; u} triv))
  in
  let open_step0 : [y] (box ff c @ y) -> [x] A (p @ x) {f @ 0 triv; *} {fun _ -> coe0 p (f @ 0 triv); *} =
    adjoin_cap0
      (bri _ -> [x] A (p @ x) {f @ 0 triv; *})
      c
      (coe0 p (f @ 0 triv))
      tube_step0
  in
  let comp1 :
    (q : [y] A (p @ 1) {coe0 p (f @ 0 triv) @ 1; *})
    * (u : decode c) -> [y] Id (A (p @ 1)) (tube_step0 u @ y @ 1) (q @ y) {*; *}
    =
    comp0_path unit
      (fun _ -> A (p @ 1))
      (fibrant_to_fib (A (p @ 1)) (fib (p @ 1)) unit)
      (bri _ -> triv)
      c
      (bri y -> fun u -> open_step0 @ y u @ 1)
  in
  let tube_step1 : [x] (decode (cof_bdy c @ x)) -> [y] A (p @ x) {coe0 p (f @ 0 triv) @ x; *} {*; *} =
    adjoin_bdy
      (bri x -> [y] A (p @ x) {coe0 p (f @ 0 triv) @ x; *})
      c
      (bri _ -> f @ 0 triv)
      (bri y -> fst comp1 @ y)
      (fun u ->
        subst_ends
          (bri x -> [y] A (p @ x) {coe0 p (f @ 0 triv) @ x; *})
          (bri x y -> tube_step0 u @ y @ x)
          (bri _ -> f @ 0 triv)
          (refl (bri _ -> f @ 0 triv))
          (bri y -> fst comp1 @ y)
          (based0ext
            (bri y -> A (p @ 1))
            (bri y -> tube_step0 u @ y @ 1)
            (bri y -> fst comp1 @ y)
            (bri y -> snd comp1 u @ y)))
  in
  let tube_step1_eq : (u : decode c)
    -> [x] Id ([y] A (p @ x) {coe0 p (f @ 0 triv) @ x; *})
           (bri y -> tube_step0 u @ y @ x)
           (tube_step1 @ x (gel x {triv; triv} u))
       {*; *}
    =
    fun u ->
    subst_ends_eq
      (bri x -> [y] A (p @ x) {coe0 p (f @ 0 triv) @ x; *})
      (bri x y -> tube_step0 u @ y @ x)
      (bri x y -> tube_step0 u @ y @ x)
      (bri _ -> f @ 0 triv)
      (refl (bri _ -> f @ 0 triv))
      (bri y -> fst comp1 @ y)
      (based0ext
        (bri y -> A (p @ 1))
        (bri y -> tube_step0 u @ y @ 1)
        (bri y -> fst comp1 @ y)
        (bri y -> snd comp1 u @ y))
      (bri x -> refl (bri y -> tube_step0 u @ y @ x))
  in
  let open_step1 : [x] [y] (box ff (cof_bdy c @ x) @ y) -> A (p @ x) {*; *} {*; *} =
    bri x ->
    adjoin_cap0
      (bri _ -> A (p @ x))
      (cof_bdy c @ x)
      (coe0 p (f @ 0 triv) @ x)
      (tube_step1 @ x)
  in
  let comp : [x] Filler unit (fun _ -> A (p @ x)) (bri _ -> triv) ff (cof_bdy c @ x) (open_step1 @ x) {*; *} =
    bri x -> fib (p @ x) ff (cof_bdy c @ x) (open_step1 @ x)
  in
  let comp_eq1 : (u : decode c) -> Id (A (p @ 1)) (f @ 1 u) (fst (comp @ 1 @ 1)) =
    fun u ->
    trans
      (A (p @ 1))
      (f @ 1 u)
      (fst comp1 @ 1)
      (fst (comp @ 1 @ 1))
      (snd comp1 u @ 1)
      (snd (comp @ 1 @ 1) triv)
  in
  bri x ->
  < fst (comp @ x @ 1)
  , fun u ->
    extent x of u in x -> box ff c @ x at x u -> Id (A (p @ x)) (f @ x u) (fst (comp @ x @ 1)) with
    | _ -> snd (comp @ 0 @ 1) triv
    | u1 -> comp_eq1 u1
    | _ u1 u x ->
      set_id_bridge_ends
        (bri x -> A (p @ x))
        (bri x -> f @ x (u @ x))
        (bri x -> fst (comp @ x @ 1))
        (snd (comp @ 0 @ 1) triv)
        (comp_eq1 u1)
        (bri x ->
          trans
            (A (p @ x))
            (f @ x (u @ x))
            (f @ x (gel x {triv; u1} triv))
            (fst (comp @ x @ 1))
            (cong
              (box ff c @ x)
              (A (p @ x))
              (f @ x)
              (u @ x)
              (gel x {triv; u1} triv)
              (gel_eta unit (decode c) (fun _ _ -> unit) triv u1 u @ x))
            (trans
              (A (p @ x))
              (f @ x (gel x {triv; u1} triv))
              (tube_step1 @ x (gel x {triv; triv} u1) @ 1)
              (fst (comp @ x @ 1))
              (cong_bapp
                (bri y -> A (p @ x))
                (bri y -> tube_step0 u1 @ y @ x)
                (tube_step1 @ x (gel x {triv; triv} u1))
                (tube_step1_eq u1 @ x)
                @ 1)
              (snd (comp @ x @ 1) (gel x {triv; triv} u1))))
        @ x
  >
